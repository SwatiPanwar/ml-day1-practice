# PyTorch User Input Fraud Detection - Smart Notes

---

## 1️⃣ Libraries Import

```python
import torch
import torch.nn as nn
import torch.optim as optim
import numpy as np
```

* torch → ML / neural networks
* nn → layers / models
* optim → optimizer
* numpy → numerical arrays

**Trick:** Think of numpy = Excel sheet + math

---

## 2️⃣ Dummy Training Data

```python
X_train = np.array([[100,10],[200,50],[5000,5],[50,60],[4000,20]], dtype=np.float32)
y_train = np.array([0,0,1,0,1], dtype=np.float32)

X_train = torch.from_numpy(X_train)
y_train = torch.from_numpy(y_train).view(-1,1)
```

* X_train = features [Amount, Time]
* y_train = labels (0=Normal,1=Fraud)
* Convert to torch tensors for PyTorch

**Trick:** PyTorch ka model numpy se input nahi le sakta directly

---

## 3️⃣ Build Model

```python
class NeuralNet(nn.Module):
    def __init__(self):
        super().__init__()
        self.fc1 = nn.Linear(2, 4)
        self.fc2 = nn.Linear(4, 1)
    def forward(self, x):
        x = torch.relu(self.fc1(x))
        x = torch.sigmoid(self.fc2(x))
        return x

model = NeuralNet()
```

* Hidden layer = 4 neurons, ReLU activation
* Output layer = 1 neuron, Sigmoid → probability

**Trick:** Hidden = learn patterns, Sigmoid = probability

---

## 4️⃣ Loss & Optimizer

```python
criterion = nn.BCELoss()
optimizer = optim.Adam(model.parameters(), lr=0.01)
```

* Loss = BCELoss → Binary classification error
* Optimizer = Adam → adjusts weights smartly

**Analogy:** Teacher checking error + adjusting weights

---

## 5️⃣ Train Model

```python
for epoch in range(50):
    optimizer.zero_grad()
    outputs = model(X_train)
    loss = criterion(outputs, y_train)
    loss.backward()
    optimizer.step()
```

* 50 epochs → model learns from data
* zero_grad → reset gradients each epoch
* backward → backpropagation
* step → update weights

**Analogy:** Student practicing repeatedly to learn patterns

---

## 6️⃣ User Input

```python
amount = float(input("Enter transaction amount: "))
time = float(input("Enter transaction time (hour 0-23): "))
user_input = torch.tensor([[amount, time]], dtype=torch.float32)
```

* Convert user input to torch tensor

**Analogy:** Customer does transaction → amount + time

---

## 7️⃣ Predict Probability

```python
prob = model(user_input).item()
prob_percent = prob*100
```

* Predict → Sigmoid output → 0–1 probability
* Convert to percentage

**Example:** prob=0.88 → 88% chance of fraud

---

## 8️⃣ Decision Threshold

```python
if prob>0.5:
    print("⚠️ Alert: Likely FRAUD!")
else:
    print("✅ Transaction NORMAL")
```

* Threshold = 0.5 → above = Fraud, below = Normal

**Trick:** Sigmoid output → Smooth S-curve → threshold 0.5

---

## 9️⃣ Daily Life Analogy Summary

* PyTorch = Flexible researcher
* Input = transaction amount & time
* Hidden layer + ReLU → notices patterns
* Output layer + Sigmoid → probability 0–1
* Decision = >0.5 → Fraud, ≤0.5 → Normal

**Trick:** PyTorch = Flexible + Research friendly + Dynamic graph
